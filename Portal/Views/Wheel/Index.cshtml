@{
    ViewData["Title"] = "Privacy Policy some changes";
}
@using Newtonsoft.Json
@model IEnumerable<Portal.Models.WheelSection>

<style>
    @@font-face {
        font-family: 'Gotham';
        src: url('/fonts/GothamMedium/Gotham Medium.otf') format('opentype');
        font-weight: normal;
        font-style: normal;
    }

    header {
        width: 100%;
    }

    body {
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        min-height: 100vh;
        margin: 0;
        font-family: 'Gotham', sans-serif;
        background: #f0f0f0;
    }

    #chartContainer {
        position: relative;
    }

    svg {
        margin: auto;
        display: flex;
        justify-content: center;
        align-content: center
    }

    #chartContainer svg {
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
    }

        #chartContainer svg .segment,
        #chartContainer svg .pencil-icon,
        #chartContainer svg .add-icon,
        #chartContainer svg .add-child-icon {
            cursor: pointer !important;
            pointer-events: all;
        }

    /* #edit::before { */
    /*     content: "\f055"; /* Font Awesome plus icon */
    /*     font-family: "Font Awesome 5 Free"; */
    /*     font-weight: 900; */
    /* } */
</style>
<!-- Loader Overlay -->
<div id="loading" style="display:none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);  /* opacity 0.5 */
            z-index: 1050;
            display: flex;
            justify-content: center;
            align-items: center;">
    <div class="spinner-border text-light" role="status">
        <span class="visually-hidden">Loading...</span>
    </div>
</div>
<div class="d-flex">




    <button class="btn btn-sm btn-primary mb-2 me-2" id="edit" onclick="toggleEdit()">
        Toggle Edit Mode
        @* <i class="fa-solid fa-plus"></i> *@
        <i class="ph ph-pen"></i>

    </button>
    <button class="btn btn-sm d-none btn-primary mb-2" onclick="openAddModal(null)">+ Add Wheel</button>
</div>

<div class="container-fluid position-relative" id="chartContainer">
    <canvas id="wheelCanvas" class="m-auto"></canvas>
</div>

<!-- Edit Modal -->
<div class="modal fade" id="editModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <form id="editForm">
                <div class="modal-header">
                    <h5 class="modal-title">Edit Section</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <input type="hidden" id="editId" />
                    <div class="mb-2">
                        <label>Name</label>
                        <input type="text" id="editName" class="form-control" />
                    </div>
                    <div class="mb-2">
                        <label>Colour</label>
                        <input type="color" id="editColour" class="form-control" />
                    </div>
                    <div class="mb-2">
                        <label for="editOrder">Order</label>
                        <input type="number" id="editOrder" class="form-control" />
                    </div>
                    <div class="mb-2">
                        <label for="editParent">Parent Section (optional)</label>
                        <select id="editParent" class="form-control">
                            <option value="">-- Top-level Section --</option>
                        </select>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-danger" onclick="saveDelete()">Delete</button>
                    <button type="button" class="btn btn-primary" onclick="saveEdit()">Save</button>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Add Modal -->
<div class="modal fade" id="addWheelModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <form id="addWheelForm">
                <div class="modal-header">
                    <h5 class="modal-title">Add Wheel Section</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-2">
                        <label for="newName">Name</label>
                        <input type="text" id="newName" class="form-control" />
                    </div>
                    <div class="mb-2">
                        <label for="newColour">Colour</label>
                        <input type="color" id="newColour" class="form-control" placeholder="#FF0000 or red" />
                    </div>
                    <div class="mb-2">
                        <label for="newOrder">Order</label>
                        <input type="number" id="newOrder" class="form-control" />
                    </div>
                    <div class="mb-2">
                        <label for="newParent">Parent Section (optional)</label>
                        <select id="newParent" disabled class="form-control">
                            <option value="">-- Top-level Section --</option>
                        </select>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-success" onclick="addNewSection()">Add</button>
                </div>
            </form>
        </div>
    </div>
</div>
@section Scripts
{
    <script>
        function adjustColor(hex, factor) {
            let r = parseInt(hex.slice(1, 3), 16);
            let g = parseInt(hex.slice(3, 5), 16);
            let b = parseInt(hex.slice(5, 7), 16);
            r = Math.min(255, Math.max(0, Math.round(r * (1 + factor))));
            g = Math.min(255, Math.max(0, Math.round(g * (1 + factor))));
            b = Math.min(255, Math.max(0, Math.round(b * (1 + factor))));
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        function debounce(func, wait) {
            let timeout;
            return function (...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }
        const debouncedDrawWheel = debounce(drawWheel, 50);

         // Initialize wheelData and DropDownData from Model
         let wheelData = @Html.Raw(JsonConvert.SerializeObject(Model));
         let DropDownData = @Html.Raw(JsonConvert.SerializeObject(Model.Where(s => s.FkParentWheelId == null).Select(s => new { s.PkWheelId, s.Name })));
         $('#loading').hide();

         console.log("WheelData",wheelData);
          console.log("DropDownData",DropDownData);
          
        let colors = [
            "#FBA969", "#FF6B6B", "#FFD93D", "#6BCB77", "#4D96FF",
            "#A66DD4", "#FF924C", "#FF5DA2", "#00C2A8", "#FFD166",
            "#EF476F", "#118AB2", "#06D6A0", "#8338EC", "#FFB703"
        ];
        let editMode = false;
        let modal = new bootstrap.Modal($('#editModal')[0]);
        let addModal = new bootstrap.Modal($('#addWheelModal')[0]);
        const canvas = document.getElementById('wheelCanvas');
        const ctx = canvas.getContext('2d');

        // Fixed wheel size
        const wheelDiameter = 400; // Fixed diameter for the wheel
        const wheelWidth = wheelDiameter;
        const wheelHeight = wheelDiameter;
        const outerRadius = wheelDiameter / 2;
        const innerRadius = outerRadius * 0.4;
        const subArcRadius = outerRadius * 1.5;
        const grandArcRadius = subArcRadius * 1.4;
        const subGap = 0.4;
        const grandGap = 0.3;
        const subSquareSize = 80;
        const grandSquareSize = 100;
        const zoomStep = 0.1;
        const minZoom = 0.5;
        const maxZoom = 2;
        const initialCanvasHeight = 1000;
        const canvasMargin = 100; // Margin around the content

        let centerX;
        let centerY;
        let selectedSegment = null;
        let selectedSubSegment = null;
        let hoveredSegment = null;

        let hoveredSubSegment = null;
        let hoveredGrandSegment = null;
        let isSubBoxesActive = false;
        let isGrandBoxesActive = false;
        let zoomLevel = 1;
        const grandCircleRadius = 50; // Adjustable radius for grandchild circles
        const SubCircleRadius = 50; // Adjustable radius for grandchild circles
        // Phosphor "pen" icon path (regular weight)
        const penPath = "M227.32,73.37,182.63,28.69a16,16,0,0,0-22.63,0L36.69,152A15.86,15.86,0,0,0,32,163.31V208a16,16,0,0,0,16,16H92.69A15.86,15.86,0,0,0,104,219.31l83.67-83.66,3.48,13.9-36.8,36.79a8,8,0,0,0,11.31,11.32l40-40a8,8,0,0,0,2.11-7.6l-6.9-27.61L227.32,96A16,16,0,0,0,227.32,73.37ZM48,179.31,76.69,208H48Zm48,25.38L51.31,160,136,75.31,180.69,120Zm96-96L147.32,64l24-24L216,84.69Z";
        // Phosphor "plus-circle" icon path (regular weight)
        const plusPath = "M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24Zm0,192a88,88,0,1,1,88-88A88.1,88.1,0,0,1,128,216Zm48-88a8,8,0,0,1-8,8H136v32a8,8,0,0,1-16,0V136H88a8,8,0,0,1,0-16h32V88a8,8,0,0,1,16,0v32h32A8,8,0,0,1,176,128Z";
        //icons font <a href="#"></a>
        const iconSize = 15;
        const scale = iconSize / 256;
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            centerX = canvas.width / 2;
            updateCanvasHeight();
            drawWheel();
        }

        function updateCanvasHeight() {
            let requiredHeight = initialCanvasHeight;

            if (isSubBoxesActive) {
                requiredHeight = 1000;//Math.max(requiredHeight, (subArcRadius + subSquareSize / 2 + canvasMargin) * 2);
            }

            if (isGrandBoxesActive) {
                requiredHeight = 1000; //Math.max(requiredHeight, (grandArcRadius + grandSquareSize / 2 + canvasMargin) * 2);
            }

            canvas.height = requiredHeight;
            centerY = canvas.height / 2;
        }

        function isPointInSegment(x, y, segmentIndex, segments) {
            const angle = (2 * Math.PI) / segments * segmentIndex;
            const nextAngle = angle + (2 * Math.PI) / segments;
            const dx = x - centerX;
            const dy = y - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy) / zoomLevel;
            const pointAngle = Math.atan2(dy, dx);
            const normalizedAngle = pointAngle < 0 ? pointAngle + 2 * Math.PI : pointAngle;
            return distance >= innerRadius && distance <= outerRadius &&
                normalizedAngle >= angle && normalizedAngle < nextAngle;
        }

        function isPointInSquare(x, y, centerXPos, centerYPos, angle, size, isHighlighted) {
            const halfSize = size / 2;
            const cosA = Math.cos(angle);
            const sinA = Math.sin(angle);
            const localX = x - centerXPos;
            const localY = y - centerYPos;
            const rotatedX = localX * cosA + localY * sinA;
            const rotatedY = -localX * sinA + localY * cosA;
            return Math.abs(rotatedX) <= halfSize && Math.abs(rotatedY) <= halfSize;
        }
        function isPointInCircle(x, y, centerXPos, centerYPos, radius) {
            const dx = x - centerXPos;
            const dy = y - centerYPos;
            return Math.sqrt(dx * dx + dy * dy) <= radius * zoomLevel;
        }
        function wrapText(text, maxWidth, fontSize) {
            ctx.font = `${fontSize * zoomLevel}px Gotham, sans-serif`;
            const scaledMaxWidth = maxWidth * zoomLevel;
            const words = text.split(' ');
            let lines = [];
            let currentLine = [];
            let currentWidth = 0;
            const maxLines = Math.floor(100 / (fontSize + (fontSize === 8 ? 16 : 18))); // Fit within 100px circle height

            for (let word of words) {
                const wordWidth = ctx.measureText(word + ' ').width;
                const testLine = [...currentLine, word].join(' ');
                const testWidth = ctx.measureText(testLine).width;

                // Check if adding the word exceeds width or if we want shorter lines (2–3 words)
                if ((testWidth > scaledMaxWidth || currentLine.length >= 3) && currentLine.length > 0) {
                    lines.push(currentLine.join(' '));
                    currentLine = [word];
                    currentWidth = wordWidth;
                } else {
                    currentLine.push(word);
                    currentWidth = testWidth;
                }

                // If we've reached the max number of lines, combine remaining words
                if (lines.length >= maxLines - 1 && words.indexOf(word) < words.length - 1) {
                    const remainingWords = words.slice(words.indexOf(word));
                    const lastLine = remainingWords.join(' ');
                    if (ctx.measureText(lastLine).width <= scaledMaxWidth) {
                        lines.push(lastLine);
                    } else {
                        // Truncate if the last line is too wide
                        let truncatedLine = '';
                        for (let w of remainingWords) {
                            const testTruncated = truncatedLine + w + ' ';
                            if (ctx.measureText(testTruncated).width <= scaledMaxWidth) {
                                truncatedLine = testTruncated;
                            } else {
                                break;
                            }
                        }
                        lines.push(truncatedLine.trim());
                    }
                    return lines;
                }
            }

            if (currentLine.length > 0) {
                lines.push(currentLine.join(' '));
            }

            return lines;
        }

        function showToast(message, type = 'success') {
            const toastContainer = document.createElement('div');
            toastContainer.className = `toast align-items-center text-white bg-${type} border-0 position-fixed bottom-0 end-0 m-3`;
            toastContainer.setAttribute('role', 'alert');
            toastContainer.setAttribute('aria-live', 'assertive');
            toastContainer.setAttribute('aria-atomic', 'true');
            toastContainer.innerHTML = `
                        <div class="d-flex">
                            <div class="toast-body">${message}</div>
                            <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                        </div>
                    `;
            document.body.appendChild(toastContainer);
            const toast = new bootstrap.Toast(toastContainer);
            toast.show();
            setTimeout(() => toastContainer.remove(), 3000);
        }
        function populateEditModal(item) {
            $('#editId').val(item.PkWheelId || '');
            $('#editName').val(item.Name);
            $('#editColour').val(item.Colour);
            $('#editOrder').val(item.Order || '');
            $('#editParent').empty();
            $('#editParent').append('<option value="">-- Top-level Section --</option>');
            DropDownData.forEach((s, i) => {
                if (s.PkWheelId !== item.PkWheelId) {
                    $('#editParent').append(`<option value="${s.PkWheelId}">${s.Name}</option>`);
                }
            });
            if (item.FkParentWheelId) {
                $('#editParent').val(item.FkParentWheelId);
            }
            console.log('Opening edit modal for item:', item);
            modal.show();
        }

        function updateDropDownData() {
            DropDownData = JSON.parse(JSON.stringify(wheelData.filter(s => !s.FkParentWheelId)));
        }

        function findSegmentIndexById(id) {
            for (let i = 0; i < wheelData.length; i++) {
                if (wheelData[i].PkWheelId === id) return i;
                for (let j = 0; j < wheelData[i].children.length; j++) {
                    if (wheelData[i].children[j].PkWheelId === id) return [i, j];
                    for (let k = 0; k < wheelData[i].children[j].children.length; k++) {
                        if (wheelData[i].children[j].children[k].PkWheelId === id) return [i, j, k];
                    }
                }
            }
            return -1;
        }

        function GetParentDropDown() {
            $.ajax({
                url: '/api/WheelApi/get-all',
                type: 'GET',
                contentType: 'application/json',
                beforeSend: function () {
                    // Show loading before request
                    $('#loading').show();
                },
                success: function (response) {
                    debugger;
                    console.log("GetParentDropDown Resp", response);
                    if (response.success) {
                        DropDownData = response.data || [];
                        wheelData = response.wheeldata || [];
                        console.log("WheelData", wheelData);
                        console.log("DropDownData", DropDownData);
                        const $editParent = $('#editParent');
                        const $newParent = $('#newParent');
                        const editVal = $editParent.val();
                        const newVal = $newParent.val();
                        $editParent.empty().append('<option value="">-- Top-level Section --</option>');
                        $newParent.empty().append('<option value="">-- Top-level Section --</option>');
                        DropDownData.forEach(section => {
                            $editParent.append(`<option value="${section.PkWheelId}">${section.Name}</option>`);
                            $newParent.append(`<option value="${section.PkWheelId}">${section.Name} (ID: ${section.PkWheelId})</option>`);
                        });
                        if (editVal) $editParent.val(editVal);
                        if (newVal) $newParent.val(newVal);
                        updateCanvasHeight();
                        drawWheel();
                    } else {
                        showToast('Failed to fetch dropdown and wheel data.', 'danger');

                    }
                },
                error: function (xhr, status, error) {
                    console.error('Fetch API Error:', xhr.responseText);

                    showToast('error to fetch dropdown and wheel data.', 'danger');
                }, complete: function () {
                    // Hide loading after request finishes
                    $('#loading').hide();
                }
            });
        }

           function drawWheel() {
            const segments = wheelData.length;
            const svg = document.querySelector('#chartContainer svg') || document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute('width', canvas.width);
            svg.setAttribute('height', canvas.height);
            svg.innerHTML = '';
            const plusGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            const childGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            if (!document.querySelector('#chartContainer svg')) {
                document.getElementById('chartContainer').appendChild(svg);
            }

            const maxRadius = outerRadius;
            const minRadius = innerRadius;
            const segmentAngle = segments > 0 ? (2 * Math.PI) / segments : 0;


            // Main segments loop
            for (let i = 0; i < segments; i++) {
                const startAngle = i * segmentAngle;
                const endAngle = (i + 1) * segmentAngle;
                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                path.setAttribute('d', `
                            M ${centerX + minRadius * Math.cos(startAngle)} ${centerY + minRadius * Math.sin(startAngle)}
                            A ${minRadius} ${minRadius} 0 0 1 ${centerX + minRadius * Math.cos(endAngle)} ${centerY + minRadius * Math.sin(endAngle)}
                            L ${centerX + maxRadius * Math.cos(endAngle)} ${centerY + maxRadius * Math.sin(endAngle)}
                            A ${maxRadius} ${maxRadius} 0 0 0 ${centerX + maxRadius * Math.cos(startAngle)} ${centerY + maxRadius * Math.sin(startAngle)}
                            Z
                        `);
                path.setAttribute('fill', wheelData[i].Colour);
                path.setAttribute('class', 'segment');
                path.setAttribute('data-segment-index', i);

                path.addEventListener('click', (event) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const y = event.clientY - rect.top;
                    if (isPointInSegment(x, y, i, segments)) {
                        if (editMode) {
                            populateEditModal(wheelData[i]);
                        } else {
                            if (selectedSegment !== i || !isSubBoxesActive) {
                                selectedSegment = i;
                                isSubBoxesActive = wheelData[i].Children.length > 0;
                                isGrandBoxesActive = false;
                                selectedSubSegment = isSubBoxesActive ? 0 : null;
                                hoveredSubSegment = null;
                                hoveredGrandSegment = null;
                                updateCanvasHeight();
                                drawWheel();
                            }
                        }
                    }
                });

                path.addEventListener('mouseover', (event) => {
                    hoveredSegment = i;
                    const midAngle = startAngle + segmentAngle / 2;
                    const offsetDistance = 10;
                    const offsetX = offsetDistance * Math.cos(midAngle);
                    const offsetY = offsetDistance * Math.sin(midAngle);
                    path.setAttribute('transform', `translate(${offsetX}, ${offsetY})`);
                    const text = path.nextSibling;
                    if (text) text.setAttribute('transform', `translate(${offsetX}, ${offsetY})`);
                    const plus = plusGroup.querySelector(`[data-add-segment-index="${i}"]`);
                    if (plus) plus.setAttribute('transform', `translate(${offsetX}, ${offsetY})`);
                    const childIcon = childGroup.querySelector(`[data-segment-index="${i}"]`);
                    if (childIcon) childIcon.setAttribute('transform', `translate(${offsetX}, ${offsetY})`);
                    selectedSegment = i;
                    isSubBoxesActive = true;
                    isGrandBoxesActive = false;
                    selectedSubSegment = isSubBoxesActive ? 0 : null;
                    hoveredSubSegment = null;
                    hoveredGrandSegment = null;
                    updateCanvasHeight();
                    drawWheel();
                });

                path.addEventListener('mouseout', () => {
                    hoveredSegment = null;

                    path.removeAttribute('transform');
                    const text = path.nextSibling;
                    if (text) text.removeAttribute('transform');
                    if (editMode) {
                        const plus = plusGroup.querySelector(`[data-add-segment-index="${i}"]`);
                        if (plus) plus.removeAttribute('transform');
                        const childIcon = childGroup.querySelector(`[data-segment-index="${i}"]`);
                        if (childIcon) childIcon.removeAttribute('transform');
                    }
                });

                if (i === selectedSegment && isSubBoxesActive) {
                    const midAngle = startAngle + segmentAngle / 2;
                    const offsetDistance = 10;
                    const offsetX = offsetDistance * Math.cos(midAngle);
                    const offsetY = offsetDistance * Math.sin(midAngle);
                    path.setAttribute('transform', `translate(${offsetX}, ${offsetY})`);
                }

                svg.appendChild(path);

                const midAngle = startAngle + segmentAngle / 2;
                const textX = centerX + (minRadius + (maxRadius - minRadius) / 2) * Math.cos(midAngle);
                const textY = centerY + (minRadius + (maxRadius - minRadius) / 2) * Math.sin(midAngle);
                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute('x', textX);
                text.setAttribute('y', textY);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dominant-baseline', 'middle');
                text.setAttribute('font-family', 'Gotham, sans-serif');
                const segmentFontSize = wheelData.length > 12 ? 10 : 12;
                text.setAttribute('font-size', segmentFontSize);
                text.setAttribute('fill', '#000');
                text.setAttribute('role', 'button');
                text.setAttribute('aria-label', `Edit ${wheelData[i].Name}`);
                text.textContent = wheelData[i].Name;

                if (i === selectedSegment && isSubBoxesActive) {
                    const offsetDistance = 10;
                    const offsetX = offsetDistance * Math.cos(midAngle);
                    const offsetY = offsetDistance * Math.sin(midAngle);
                    text.setAttribute('transform', `translate(${offsetX}, ${offsetY})`);
                }
                svg.appendChild(text);
            }

            if (editMode) {
                for (let i = 0; i < segments; i++) {
                    const startAngle = i * segmentAngle;
                    const midAngle = startAngle + segmentAngle / 2;
                    const boundaryAngle = startAngle;

                    //const pencilX = centerX + (maxRadius-50) * Math.cos(boundaryAngle);
                    //const pencilY = centerY + (maxRadius-50) * Math.sin(boundaryAngle);
                    const pencilX = (centerX + (minRadius + (maxRadius - minRadius) / 2) * Math.cos(midAngle)) - 10;
                    const pencilY = (centerY + (minRadius + (maxRadius - minRadius) / 2) * Math.sin(midAngle)) - 15;


                    const pencilGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
                    pencilGroup.setAttribute('transform', `translate(${pencilX - iconSize / 2}, ${pencilY - iconSize / 2}) scale(${scale})`);
                    const pencilPathElem = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    pencilPathElem.setAttribute('d', penPath);
                    pencilPathElem.setAttribute('fill', '#000');
                    pencilGroup.appendChild(pencilPathElem);
                    pencilGroup.setAttribute('class', 'pencil-icon');
                    pencilGroup.setAttribute('tabindex', '0');
                    pencilGroup.setAttribute('role', 'button');
                    pencilGroup.setAttribute('aria-label', `Edit ${wheelData[i].Name}`);
                    pencilGroup.addEventListener('click', () => {
                        populateEditModal(wheelData[i]);
                    });

                    // Add icon for adding between segments
                    const plusX = centerX + (maxRadius - 20) * Math.cos(boundaryAngle);
                    const plusY = centerY + (maxRadius - 20) * Math.sin(boundaryAngle);

                    const addGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
                    addGroup.setAttribute('transform', `translate(${plusX - iconSize / 2}, ${plusY - iconSize / 2}) scale(${scale})`);
                    const addPathElem = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    addPathElem.setAttribute('d', plusPath);
                    addPathElem.setAttribute('fill', '#000');
                    addGroup.appendChild(addPathElem);
                    addGroup.setAttribute('class', 'add-icon');
                    addGroup.setAttribute('data-add-segment-index', i);
                    addGroup.setAttribute('role', 'button');
                    addGroup.setAttribute('tabindex', '0');

                    addGroup.setAttribute('aria-label', `Add segment after ${wheelData[i].Name}`);
                    addGroup.addEventListener("click", () => {
                        openAddModal(wheelData[i]);
                    })
                    // Add icon for adding child segment (only for active or hovered segment)
                    if ((i === selectedSegment || i === hoveredSegment) && wheelData[selectedSegment].Children.length <= 0) {
                        const childX = centerX + (maxRadius + 30) * Math.cos(midAngle);
                        const childY = centerY + (maxRadius + 30) * Math.sin(midAngle);
                        const childAddGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
                        childAddGroup.setAttribute('transform', `translate(${childX - iconSize / 2}, ${childY - iconSize / 2}) scale(${scale})`);
                        const childPathElem = document.createElementNS("http://www.w3.org/2000/svg", "path");
                        childPathElem.setAttribute('d', plusPath);
                        childPathElem.setAttribute('fill', '#0066cc');
                        childAddGroup.appendChild(childPathElem);
                        childAddGroup.setAttribute('class', 'add-child-icon');
                        childAddGroup.setAttribute('data-segment-index', i);
                        childAddGroup.setAttribute('role', 'button');
                        childAddGroup.setAttribute('aria-label', `Add child to ${wheelData[i].Name}`);
                        childAddGroup.setAttribute('tabindex', '0');

                        childAddGroup.addEventListener("click", () => {
                            openAddSegmentChildModal(wheelData[i]);
                        });
                        childGroup.appendChild(childAddGroup);
                        const offsetDistance = 1;
                        const offsetX = offsetDistance * Math.cos(midAngle);
                        const offsetY = offsetDistance * Math.sin(midAngle);
                        childAddGroup.setAttribute('transform', `translate(${childX - iconSize / 2 + offsetX}, ${childY - iconSize / 2 + offsetY}) scale(${scale})`);

                    }

                    if (i === selectedSegment && isSubBoxesActive) {
                        const offsetDistance = 10;
                        const offsetX = offsetDistance * Math.cos(midAngle);
                        const offsetY = offsetDistance * Math.sin(midAngle);
                        pencilGroup.setAttribute('transform', `translate(${pencilX - iconSize / 2 + offsetX}, ${pencilY - iconSize / 2 + offsetY}) scale(${scale})`);
                        addGroup.setAttribute('transform', `translate(${plusX - iconSize / 2 + offsetX}, ${plusY - iconSize / 2 + offsetY}) scale(${scale})`);
                    }

                    svg.appendChild(pencilGroup);
                    plusGroup.appendChild(addGroup);
                }
                svg.appendChild(plusGroup);
                svg.appendChild(childGroup);
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(zoomLevel, zoomLevel);
            ctx.translate(-centerX, -centerY);

            const angle = segments > 0 ? (2 * Math.PI) / segments : 0;

            if (isSubBoxesActive && selectedSegment !== null) {
                const subSegments = wheelData[selectedSegment].Children.length;
                if (subSegments > 0) {
                    const segmentAngle = selectedSegment * angle + angle / 2;
                    const subAngle = subSegments > 1 ? (angle * 0.5 + subGap * (subSegments - 1)) / (subSegments - 1) : angle * 0.8;
                    const subStartAngle = segmentAngle - (subSegments > 1 ? (angle * 0.25 + subGap * (subSegments - 1) / 2) : 0);

                    if (editMode) {
                        // Always add plus icon before the first sub-segment

                        const beforeFirstSubAngle = subStartAngle - (subSegments > 0 ? subAngle / 2 : 0);
                        const beforeSubPlusX = centerX + subArcRadius * Math.cos(beforeFirstSubAngle);
                        const beforeSubPlusY = centerY + subArcRadius * Math.sin(beforeFirstSubAngle);
                        const subAddGroupBefore = document.createElementNS("http://www.w3.org/2000/svg", "g");
                        subAddGroupBefore.setAttribute('transform', `translate(${beforeSubPlusX - iconSize / 2}, ${beforeSubPlusY - iconSize / 2}) scale(${scale})`);
                        const subAddPathElemBefore = document.createElementNS("http://www.w3.org/2000/svg", "path");
                        subAddPathElemBefore.setAttribute('d', plusPath);
                        subAddPathElemBefore.setAttribute('fill', '#383737');
                        subAddGroupBefore.appendChild(subAddPathElemBefore);
                        subAddGroupBefore.setAttribute('class', 'add-icon');
                        subAddGroupBefore.setAttribute('role', 'button');
                        subAddGroupBefore.setAttribute('aria-label', `Add sub-segment after last sub-segment of ${wheelData[selectedSegment].Name}`);
                        subAddGroupBefore.setAttribute('tabindex', '0');
                        subAddGroupBefore.addEventListener('click', () => {
                            openAddModal(wheelData[selectedSegment].Children[0]);

                        });
                        svg.appendChild(subAddGroupBefore);
                    }

                    for (let i = 0; i < subSegments; i++) {
                        const boxAngle = subStartAngle + (subSegments > 1 ? i * subAngle : 0);
                        const boxX = centerX + subArcRadius * Math.cos(boxAngle);
                        const boxY = centerY + subArcRadius * Math.sin(boxAngle);
                        const isSelectedSub = i === selectedSubSegment && isGrandBoxesActive;
                        const isHoveredSub = i === hoveredSubSegment;
                        const subScaleFactor = isSelectedSub ? 0.9 : 0.8;
                        const scaledSubSize = SubCircleRadius * subScaleFactor;

                        ctx.save();
                        ctx.translate(boxX, boxY);
                        ctx.beginPath();
                        //  ctx.rect(-scaledSubSize / 2, -scaledSubSize / 2, scaledSubSize, scaledSubSize);
                        ctx.arc(0, 0, SubCircleRadius, 0, 2 * Math.PI);

                        ctx.fillStyle = isHoveredSub ? adjustColor(wheelData[selectedSegment].Children[i].Colour, 0.3) : (isSelectedSub ? adjustColor(wheelData[selectedSegment].Children[i].Colour, 0.2) : wheelData[selectedSegment].Children[i].Colour);
                        if (isSelectedSub) {
                            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                            ctx.shadowBlur = 10 / zoomLevel;
                            ctx.shadowOffsetX = 0;
                            ctx.shadowOffsetY = 0;
                        }
                        ctx.fill();
                        ctx.restore();

                        ctx.save();
                        ctx.translate(boxX, boxY);
                        ctx.fillStyle = '#000';
                        const subBoxFontSize = wheelData[selectedSegment].Children[i].Name.length > 5 ? 8 : 10;
                        ctx.font = `${subBoxFontSize * zoomLevel}px Gotham, sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const lines = wrapText(wheelData[selectedSegment].Children[i].Name, SubCircleRadius, subBoxFontSize);
                        lines.forEach((line, index) => {
                            ctx.fillText(line, 0, (index - (lines.length - 1) / 2) * 18);
                        });
                        ctx.restore();

                        if (editMode) {

                            // Add icon for adding between sub-segments (only if subSegments > 1 and i < subSegments - 1)
                            let subPlusX, subPlusY;
                            if (subSegments > 1 && i < subSegments - 1) {
                                const nextBoxAngle = subStartAngle + ((i + 1) * subAngle);
                                const midAngle = (boxAngle + nextBoxAngle) / 2;
                                subPlusX = centerX + subArcRadius * Math.cos(midAngle);
                                subPlusY = centerY + subArcRadius * Math.sin(midAngle);
                                const subAddGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
                                subAddGroup.setAttribute('transform', `translate(${subPlusX - iconSize / 2}, ${subPlusY - iconSize / 2}) scale(${scale})`);
                                const subAddPathElem = document.createElementNS("http://www.w3.org/2000/svg", "path");
                                subAddPathElem.setAttribute('d', plusPath);
                                subAddPathElem.setAttribute('fill', '#383737');
                                subAddGroup.appendChild(subAddPathElem);
                                subAddGroup.setAttribute('class', 'add-icon');
                                subAddGroup.setAttribute('role', 'button');
                                subAddGroup.setAttribute('aria-label', `Add sub-segment after ${wheelData[selectedSegment].Children[i].Name}`);
                                subAddGroup.setAttribute('tabindex', '0');
                                subAddGroup.addEventListener('click', () => {

                                    openAddModal(wheelData[selectedSegment].Children[i]);
                                });
                                svg.appendChild(subAddGroup);
                            }

                            // Add icon for adding child to sub-segment (only if hovered or selected)
                            if ((isHoveredSub || isSelectedSub) && wheelData[selectedSegment].Children[i].Children.length <= 0) {
                                const isLeftSide = boxX < centerX;
                                const offset = isLeftSide ? 15 : 30; // Distance from circle edge
                                const iconAngle = boxAngle;
                                const subChildX = boxX + (SubCircleRadius + offset) * Math.cos(iconAngle);
                                const subChildY = boxY + (SubCircleRadius + offset) * Math.sin(iconAngle);

                                const subChildAddGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
                                subChildAddGroup.setAttribute('transform', `translate(${subChildX - iconSize / 2}, ${subChildY - iconSize / 2}) scale(${scale})`);
                                const subChildPathElem = document.createElementNS("http://www.w3.org/2000/svg", "path");
                                subChildPathElem.setAttribute('d', plusPath);
                                subChildPathElem.setAttribute('fill', '#383737');
                                subChildAddGroup.appendChild(subChildPathElem);
                                subChildAddGroup.setAttribute('class', 'add-child-icon');
                                subChildAddGroup.setAttribute('role', 'button');
                                subChildAddGroup.setAttribute('aria-label', `Add child to ${wheelData[selectedSegment].Children[i].Name}`);
                                subChildAddGroup.setAttribute('tabindex', '0');
                                subChildAddGroup.addEventListener('click', () => {
                                    openAddSegmentChildModal(wheelData[selectedSegment].Children[i]);
                                });
                                svg.appendChild(subChildAddGroup);
                            }

                            // Add pencil icon for editing sub-segment (bottom-right corner)
                            const subPencilX = boxX + 20;
                            const subPencilY = boxY - scaledSubSize * zoomLevel; // Above circle
                            const subPencilGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
                            subPencilGroup.setAttribute('transform', `translate(${subPencilX - iconSize / 2}, ${subPencilY - iconSize / 2}) scale(${scale})`);
                            const subPencilPathElem = document.createElementNS("http://www.w3.org/2000/svg", "path");
                            subPencilPathElem.setAttribute('d', penPath);
                            subPencilPathElem.setAttribute('fill', '#000');
                            subPencilGroup.appendChild(subPencilPathElem);
                            subPencilGroup.setAttribute('class', 'pencil-icon');
                            subPencilGroup.setAttribute('role', 'button');
                            subPencilGroup.setAttribute('aria-label', `Edit ${wheelData[selectedSegment].Children[i].Name}`);
                            subPencilGroup.setAttribute('tabindex', '0');
                            subPencilGroup.addEventListener('click', () => populateEditModal(wheelData[selectedSegment].Children[i]));
                            subPencilGroup.addEventListener('keydown', (event) => {
                                if (event.key === 'Enter' || event.key === ' ') {
                                    populateEditModal(wheelData[selectedSegment].Children[i]);
                                }
                            });
                            svg.appendChild(subPencilGroup);
                        }

                        if ((isGrandBoxesActive && i === selectedSubSegment && wheelData[selectedSegment].Children[i].Children.length > 0) ||
                            (i === hoveredSubSegment && wheelData[selectedSegment].Children[i].Children.length > 0)) {
                            const grandSegments = wheelData[selectedSegment].Children[i].Children.length;
                            const subBoxAngle = subStartAngle + (subSegments > 1 ? i * subAngle : 0);
                            const minAngularGap = Math.asin((grandCircleRadius * 1.2) / grandArcRadius);
                            const grandAngle = grandSegments > 1 ? Math.max((subAngle * 0.6 + grandGap * (grandSegments - 1)) / (grandSegments - 1), minAngularGap) : Math.max(subAngle * 0.2 + grandGap);
                            const totalGrandAngle = grandSegments > 1 ? (grandSegments - 1) * grandAngle : 0;
                            const grandStartAngle = subBoxAngle - (totalGrandAngle / 2);

                            // Add plus icon before the first grand-segment
                            if (editMode) {
                                const beforeFirstGrandAngle = grandStartAngle - (grandSegments > 0 ? grandAngle / 2 : 0);
                                const beforeGrandPlusX = centerX + grandArcRadius * Math.cos(beforeFirstGrandAngle);
                                const beforeGrandPlusY = centerY + grandArcRadius * Math.sin(beforeFirstGrandAngle);
                                const grandAddGroupBefore = document.createElementNS("http://www.w3.org/2000/svg", "g");
                                grandAddGroupBefore.setAttribute('transform', `translate(${beforeGrandPlusX - iconSize / 2}, ${beforeGrandPlusY - iconSize / 2}) scale(${scale})`);
                                const grandAddPathElemBefore = document.createElementNS("http://www.w3.org/2000/svg", "path");
                                grandAddPathElemBefore.setAttribute('d', plusPath);
                                grandAddPathElemBefore.setAttribute('fill', '#383737');
                                grandAddGroupBefore.appendChild(grandAddPathElemBefore);
                                grandAddGroupBefore.setAttribute('class', 'add-icon');
                                grandAddGroupBefore.setAttribute('role', 'button');
                                grandAddGroupBefore.setAttribute('aria-label', `Add grand-segment before first grand-segment of ${wheelData[selectedSegment].Children[i].Name}`);
                                grandAddGroupBefore.setAttribute('tabindex', '0');
                                grandAddGroupBefore.addEventListener('click', () => {
                                    openAddSegmentChildModal(wheelData[selectedSegment].Children[i]);

                                });
                                svg.appendChild(grandAddGroupBefore);
                            }

                            for (let j = 0; j < grandSegments; j++) {
                                const grandBoxAngle = grandStartAngle + (grandSegments > 1 ? j * grandAngle : 0);
                                const grandBoxX = centerX + grandArcRadius * Math.cos(grandBoxAngle);
                                const grandBoxY = centerY + grandArcRadius * Math.sin(grandBoxAngle);

                                ctx.save();
                                ctx.translate(grandBoxX, grandBoxY);
                                ctx.beginPath();
                                // ctx.rect(-grandSquareSize / 2, -grandSquareSize / 2, grandSquareSize, grandSquareSize); // don't remove these line
                                ctx.arc(0, 0, grandCircleRadius, 0, 2 * Math.PI);
                                ctx.fillStyle = j === hoveredGrandSegment && i === (editMode ? selectedSubSegment : hoveredSubSegment) ?
                                    adjustColor(wheelData[selectedSegment].Children[i].Children[j].Colour, 0.3) :
                                    wheelData[selectedSegment].Children[i].Children[j].Colour;
                                ctx.fill();
                                ctx.restore();

                                ctx.save();
                                ctx.translate(grandBoxX, grandBoxY);
                                ctx.fillStyle = '#000';
                                const grandBoxFontSize = wheelData[selectedSegment].Children[i].Children[j].Name.length > 4 ? 8 : 10;
                                ctx.font = `${grandBoxFontSize * zoomLevel}px Gotham, sans-serif`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';

                                const lines = wrapText(wheelData[selectedSegment].Children[i].Children[j].Name, grandCircleRadius, grandBoxFontSize);
                                lines.forEach((line, index) => {
                                    ctx.fillText(line, 0, (index - (lines.length - 1) / 2) * 16);
                                });
                                ctx.restore();

                                if (editMode && grandSegments > 1 && j < grandSegments - 1) {

                                    const nextGrandBoxAngle = grandStartAngle + ((j + 1) * grandAngle);
                                    const midGrandAngle = (grandBoxAngle + nextGrandBoxAngle) / 2;
                                    const grandPlusX = centerX + grandArcRadius * Math.cos(midGrandAngle);
                                    const grandPlusY = centerY + grandArcRadius * Math.sin(midGrandAngle);
                                    const grandAddGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
                                    grandAddGroup.setAttribute('transform', `translate(${grandPlusX - iconSize / 2}, ${grandPlusY - iconSize / 2}) scale(${scale})`);
                                    const grandAddPathElem = document.createElementNS("http://www.w3.org/2000/svg", "path");
                                    grandAddPathElem.setAttribute('d', plusPath);
                                    grandAddPathElem.setAttribute('fill', '#383737');
                                    grandAddGroup.appendChild(grandAddPathElem);
                                    grandAddGroup.setAttribute('class', 'add-icon');
                                    grandAddGroup.setAttribute('role', 'button');
                                    grandAddGroup.setAttribute('aria-label', `Add grand-segment after ${wheelData[selectedSegment].Children[i].Children[j].Name}`);
                                    grandAddGroup.setAttribute('tabindex', '0');
                                    grandAddGroup.addEventListener('click', () => {
                                        openAddModal(wheelData[selectedSegment].Children[i].Children[j]);
                                    });
                                    svg.appendChild(grandAddGroup);
                                }
                                if (editMode) {
                                    // Add pencil icon for editing grandchild-segment (bottom-right corner)
                                    const grandPencilX = grandBoxX + 10;
                                    const grandPencilY = grandBoxY - grandCircleRadius + 20 * zoomLevel; // Above circle
                                    const grandPencilGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
                                    grandPencilGroup.setAttribute('transform', `translate(${grandPencilX - iconSize / 2}, ${grandPencilY - iconSize / 2}) scale(${scale})`);
                                    const grandPencilPathElem = document.createElementNS("http://www.w3.org/2000/svg", "path");
                                    grandPencilPathElem.setAttribute('d', penPath);
                                    grandPencilPathElem.setAttribute('fill', '#000');
                                    grandPencilGroup.appendChild(grandPencilPathElem);
                                    grandPencilGroup.setAttribute('class', 'pencil-icon');
                                    grandPencilGroup.setAttribute('role', 'button');
                                    grandPencilGroup.setAttribute('aria-label', `Edit ${wheelData[selectedSegment].Children[i].Children[j].Name}`);
                                    grandPencilGroup.setAttribute('tabindex', '0');
                                    grandPencilGroup.addEventListener('click', () => populateEditModal(wheelData[selectedSegment].Children[i].Children[j]));
                                    grandPencilGroup.addEventListener('keydown', (event) => {
                                        if (event.key === 'Enter' || event.key === ' ') {
                                            populateEditModal(wheelData[selectedSegment].Children[i].Children[j]);
                                        }
                                    });
                                    svg.appendChild(grandPencilGroup);
                                // Always add plus icon after the last grand-segment
                                if (j === grandSegments - 1) {
                                    const afterLastGrandAngle = grandStartAngle + totalGrandAngle + (grandSegments > 0 ? grandAngle / 2 : 0);
                                    const afterGrandPlusX = centerX + grandArcRadius * Math.cos(afterLastGrandAngle);
                                    const afterGrandPlusY = centerY + grandArcRadius * Math.sin(afterLastGrandAngle);
                                    const grandAddGroupAfter = document.createElementNS("http://www.w3.org/2000/svg", "g");
                                    grandAddGroupAfter.setAttribute('transform', `translate(${afterGrandPlusX - iconSize / 2}, ${afterGrandPlusY - iconSize / 2}) scale(${scale})`);
                                    const grandAddPathElemAfter = document.createElementNS("http://www.w3.org/2000/svg", "path");
                                    grandAddPathElemAfter.setAttribute('d', plusPath);
                                    grandAddPathElemAfter.setAttribute('fill', '#383737');
                                    grandAddGroupAfter.appendChild(grandAddPathElemAfter);
                                    grandAddGroupAfter.setAttribute('class', 'add-icon');
                                    grandAddGroupAfter.setAttribute('role', 'button');
                                    grandAddGroupAfter.setAttribute('aria-label', `Add grand-segment after last grand-segment of ${wheelData[selectedSegment].Children[i].Name}`);
                                    grandAddGroupAfter.setAttribute('tabindex', '0');
                                    grandAddGroupAfter.addEventListener('click', () => {
                                        openAddModal(wheelData[selectedSegment].Children[i].Children[j]);

                                    });
                                    grandAddGroupAfter.addEventListener('keydown', (event) => {
                                        if (event.key === 'Enter' || event.key === ' ') {
                                            openAddModal(wheelData[selectedSegment].Children[i].Children[j]);

                                        }
                                    });
                                    svg.appendChild(grandAddGroupAfter);
                                }
                                }
                            }


                            if (editMode && wheelData[selectedSegment].Children[i].Children.length < 14) {
                                // Add plus icon after the last grand-segment
                                const afterLastGrandAngle = grandStartAngle + totalGrandAngle + (grandSegments > 0 ? grandAngle / 2 : 0);
                                const afterGrandPlusX = centerX + grandArcRadius * Math.cos(afterLastGrandAngle);
                                const afterGrandPlusY = centerY + grandArcRadius * Math.sin(afterLastGrandAngle);
                                const grandAddGroupAfter = document.createElementNS("http://www.w3.org/2000/svg", "g");
                                grandAddGroupAfter.setAttribute('transform', `translate(${afterGrandPlusX - iconSize / 2}, ${afterGrandPlusY - iconSize / 2}) scale(${scale})`);
                                const grandAddPathElemAfter = document.createElementNS("http://www.w3.org/2000/svg", "path");
                                grandAddPathElemAfter.setAttribute('d', plusPath);
                                grandAddPathElemAfter.setAttribute('fill', '#383737');
                                grandAddGroupAfter.appendChild(grandAddPathElemAfter);
                                grandAddGroupAfter.setAttribute('class', 'add-icon');
                                grandAddGroupAfter.addEventListener('click', () => {
                                    openAddSegmentChildModal(wheelData[selectedSegment].Children[i]);

                                });
                                svg.appendChild(grandAddGroupAfter);
                            }

                        }
                    }

                    // Add plus icon after the last sub-segment
                    if (editMode && wheelData[selectedSegment].Children.length < 14) {

                        const afterLastSubAngle = subStartAngle + (subSegments > 1 ? (subSegments - 1) * subAngle : 0) + (subSegments > 0 ? subAngle / 2 : 0);
                        const afterSubPlusX = centerX + subArcRadius * Math.cos(afterLastSubAngle);
                        const afterSubPlusY = centerY + subArcRadius * Math.sin(afterLastSubAngle);
                        const subAddGroupAfter = document.createElementNS("http://www.w3.org/2000/svg", "g");
                        subAddGroupAfter.setAttribute('transform', `translate(${afterSubPlusX - iconSize / 2}, ${afterSubPlusY - iconSize / 2}) scale(${scale})`);
                        const subAddPathElemAfter = document.createElementNS("http://www.w3.org/2000/svg", "path");
                        subAddPathElemAfter.setAttribute('d', plusPath);
                        subAddPathElemAfter.setAttribute('fill', '#383737');
                        subAddGroupAfter.appendChild(subAddPathElemAfter);
                        subAddGroupAfter.setAttribute('class', 'add-icon');
                        subAddGroupAfter.addEventListener('click', () => {
                            openAddModal(wheelData[selectedSegment].Children[wheelData[selectedSegment].Children.length - 1]);

                        });
                        svg.appendChild(subAddGroupAfter);
                    }
                }
            }
            ctx.restore();
        }

        // SVG click handler for main segment plus icons
        document.getElementById('chartContainer').addEventListener('click', (event) => {
            const svg = document.querySelector('#chartContainer svg');
            if (!svg.contains(event.target)) return;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            const segments = wheelData.length;
            const angle = (2 * Math.PI) / segments;

            if (editMode) {
                for (let i = 0; i < segments; i++) {
                    const startAngle = i * angle;
                    const midAngle = startAngle + angle / 2;
                    let plusX, plusY;
                    if (segments > 1) {
                        const nextAngle = (i + 1) * angle;
                        const betweenAngle = (startAngle + nextAngle) / 2;
                        plusX = centerX + outerRadius * Math.cos(betweenAngle);
                        plusY = centerY + outerRadius * Math.sin(betweenAngle);
                    } else {
                        plusX = centerX + (outerRadius + 20) * Math.cos(midAngle);
                        plusY = centerY + (outerRadius + 20) * Math.sin(midAngle);
                    }
                    const childX = centerX + (outerRadius + 30) * Math.cos(midAngle);
                    const childY = centerY + (outerRadius + 30) * Math.sin(midAngle);
                    // if (isPointInSquare(x, y, plusX, plusY, midAngle, 20, false)) {
                    if (isPointInCircle(x, y, plusX, plusY, 10 * zoomLevel)) {

                        AddNewSegment(wheelData[i]);
                        return;
                    }
                    //if (isPointInSquare(x, y, childX, childY, midAngle, 20, false)) {
                    if (isPointInCircle(x, y, childX, childY, 10 * zoomLevel)) {

                        openAddModal(wheelData[i]);
                        return;
                    }
                }
            }
        });

        canvas.addEventListener('mousemove', (event) => {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const segments = wheelData.length;
            const angle = (2 * Math.PI) / segments;
            let hoverChanged = false;
            let subBoxHovered = false;
            let grandBoxHovered = false;
            // Check main segments for hover
            let segmentHovered = false;
            for (let i = 0; i < segments; i++) {
                if (isPointInSegment(x, y, i, segments)) {
                    if (hoveredSegment !== i) {
                        hoveredSegment = i;
                        hoverChanged = true;
                    }
                    segmentHovered = true;
                    break;
                }
            }
            if (!segmentHovered && hoveredSegment !== null) {
                hoveredSegment = null;
                hoverChanged = true;
            }

            if (isSubBoxesActive && selectedSegment !== null) {
                const subSegments = wheelData[selectedSegment].Children.length;
                if (subSegments > 0) {
                    const segmentAngle = selectedSegment * angle + angle / 2;
                    const subAngle = subSegments > 1 ? (angle * 0.5 + subGap * (subSegments - 1)) / (subSegments - 1) : 0;
                    const subStartAngle = segmentAngle - (subSegments > 1 ? (angle * 0.25 + subGap * (subSegments - 1) / 2) : 0);

                    for (let i = 0; i < subSegments; i++) {
                        const boxAngle = subStartAngle + (subSegments > 1 ? i * subAngle : 0);
                        const boxX = centerX + subArcRadius * Math.cos(boxAngle);
                        const boxY = centerY + subArcRadius * Math.sin(boxAngle);
                        const isSelectedSub = i === selectedSubSegment && isGrandBoxesActive;
                        const subScaleFactor = isSelectedSub ? 0.9 : 0.8;
                        const scaledSubSize = subSquareSize * subScaleFactor;

                        // if (isPointInSquare(x, y, boxX, boxY, boxAngle, scaledSubSize, isSelectedSub)) {
                        if (isPointInCircle(x, y, boxX, boxY, scaledSubSize)) {

                            if (hoveredSubSegment !== i) {
                                hoveredSubSegment = i;
                                hoveredGrandSegment = null;
                                if (editMode) {
                                    selectedSubSegment = i;
                                    isGrandBoxesActive = wheelData[selectedSegment].Children[i].Children.length > 0;
                                    updateCanvasHeight();
                                }
                                hoverChanged = true;
                            }
                            subBoxHovered = true;
                            break;
                        }
                    }

                    if (!subBoxHovered && isSubBoxesActive) {
                        for (let i = 0; i < subSegments; i++) {
                            const boxAngle = subStartAngle + (subSegments > 1 ? i * subAngle : 0);
                            if (wheelData[selectedSegment].Children[i].Children.length > 0) {
                                const subBoxAngle = subStartAngle + (subSegments > 1 ? i * subAngle : 0);
                                const grandSegments = wheelData[selectedSegment].Children[i].Children.length;
                                const minAngularGap = Math.asin((grandCircleRadius * 1.2) / grandArcRadius);
                                const grandAngle = grandSegments > 1 ? Math.max((subAngle * 0.6 + grandGap * (grandSegments - 1)) / (grandSegments - 1), minAngularGap) : 0;
                                const totalGrandAngle = grandSegments > 1 ? (grandSegments - 1) * grandAngle : 0;
                                const grandStartAngle = subBoxAngle - (totalGrandAngle / 2);

                                grandBoxHovered = false;
                                for (let j = 0; j < grandSegments; j++) {
                                    const grandBoxAngle = grandStartAngle + (grandSegments > 1 ? j * grandAngle : 0);
                                    const grandBoxX = centerX + grandArcRadius * Math.cos(grandBoxAngle);
                                    const grandBoxY = centerY + grandArcRadius * Math.sin(grandBoxAngle);

                                    //   if (isPointInSquare(x, y, grandBoxX, grandBoxY, grandBoxAngle, grandSquareSize, false)) {
                                    if (isPointInCircle(x, y, grandBoxX, grandBoxY, grandCircleRadius)) {

                                        if (hoveredGrandSegment !== j || hoveredSubSegment !== i) {
                                            hoveredSubSegment = i;
                                            selectedSubSegment = i;
                                            isGrandBoxesActive = true;
                                            hoveredGrandSegment = j;
                                            updateCanvasHeight();
                                            hoverChanged = true;
                                        }
                                        grandBoxHovered = true;
                                        break;
                                    }
                                }

                                if (grandBoxHovered) break;
                            }
                        }

                        if (!subBoxHovered && !grandBoxHovered && hoveredGrandSegment !== null) {
                            hoveredGrandSegment = null;
                            hoverChanged = true;
                        }
                    }
                }
            }

            if (hoverChanged) {
                debouncedDrawWheel();
            }
        });

        function saveEdit() {
            const id = $('#editId').val();
            const name = $('#editName').val();
            const colour = $('#editColour').val();
            const order = parseInt($('#editOrder').val());
            const parent = $('#editParent').val() ? parseInt($('#editParent').val()) : null;

            if (!name || !colour || isNaN(order)) {
                alert('Please fill in all required fields.');
                return;
            }

            const data = { PkWheelId: id, Name: name, Colour: colour, Order: order, FkParentWheelId: parent };
            const Json = JSON.stringify(data);
            console.log("json", Json);
            $.ajax({
                url: '/api/WheelApi/save',
                type: 'POST',
                contentType: 'application/json',
                data: Json,
                success: function (response) {
                    console.log("Resp", response);
                    if (response.success) {
                        showToast('Section updated successfully!');

                        GetParentDropDown();
                        modal.hide();
                    } else {
                        showToast('Failed to update section.', 'danger');

                    }
                },
                error: function (xhr, status, error) {
                    showToast('Error occurred during update', 'danger');

                }
            });
        }

        function saveDelete() {
            const userConfirmed = confirm("Are you sure you want to delete this record?");
            if (!userConfirmed) return;

            const id = $('#editId').val();
            if (!id) {
                alert("Invalid record ID.");
                return;
            }

            const data = { PkWheelId: id };
            const Json = JSON.stringify(data);
            console.log("json", Json);
            $.ajax({
                url: '/api/WheelApi/delete',
                type: 'POST',
                contentType: 'application/json',
                data: Json,
                success: function (response) {
                    console.log("Resp", response);
                    if (response.success) {
                        showToast('Section deleted successfully!');

                        GetParentDropDown();
                        modal.hide();
                    } else {

                        showToast('Failed to delete section.', 'danger');
                    }
                },
                error: function (xhr, status, error) {

                    showToast('Error occurred during update.', 'danger');
                }
            });
        }

        function openAddModal(item) {
            console.log("Adding new segment after item:", item);

            const parentId = item.FkParentWheelId || null;
            let order = item.order ? item.order - 1 : 1;
            if (parentId != null) {
                order = item.order ? item.order + 1 : 1;
            }
            $('#newName').val('new segment');
            $('#newColour').val(colors[Math.floor(Math.random() * colors.length)]);
            $('#newOrder').val(order);
            $('#newParent').empty();
            const $dropdown = $('#newParent');
            $dropdown.empty().append('<option value="">-- Top-level Section --</option>');
            DropDownData.forEach(section => {
                $dropdown.append(`<option value="${section.PkWheelId}">${section.Name} (ID: ${section.PkWheelId})</option>`);
            });
            if (parentId != null && parentId > 0) {
                $('#newParent').val(parentId);
            } else {
                $('#newParent').attr("disable", false)
            }
            addModal.show();
        }

        function openAddSegmentChildModal(item) {
            debugger;
            console.log("Adding new segment after item:", item);
          //  $('#newParent').attr("disable", false)

            const parentId = item.PkWheelId || null;
            let order = 1;

            $('#newName').val('new segment');
            $('#newColour').val(colors[Math.floor(Math.random() * colors.length)]);
            $('#newOrder').val(order);
            $('#newParent').empty();
            const $dropdown = $('#newParent');
            $dropdown.empty().append('<option value="">-- Top-level Section --</option>');
            DropDownData.forEach(section => {
                $dropdown.append(`<option value="${section.PkWheelId}">${section.Name} (ID: ${section.PkWheelId})</option>`);
            });
            if (parentId != null && parentId > 0) {
                $('#newParent').val(parentId);
              //  $('#newParent').attr("disable", true)

            }
            addModal.show();
        }

        function addNewSection() {
            const name = $('#newName').val();
            const colour = $('#newColour').val();
            const order = parseInt($('#newOrder').val());
            const parent = $('#newParent').val() ? parseInt($('#newParent').val()) : null;

            if (!name || !colour || isNaN(order)) {
                alert('Please fill in all required fields.');
                return;
            }

            const data = { Name: name, Colour: colour, Order: order, FkParentWheelId: parent };
            const json = JSON.stringify(data);
            console.log("Add JSON", json);
            $.ajax({
                url: '/api/WheelApi/save',
                type: 'POST',
                contentType: 'application/json',
                data: json,
                success: function (response) {
                    console.log("Add Resp", response);
                    if (response.success) {
                        showToast('Section added successfully!');
                        GetParentDropDown();
                        addModal.hide();
                    } else {
                        showToast('Failed to add section.', 'danger');
                    }
                },
                error: function () {
                    showToast('Error occurred during add.', 'danger');
                }
            });
        }


        function AddNewSegment(item) {
            console.log("Adding new segment after item:", item);
            const parentId = item.FkParentWheelId || null;
            let order = item.order ? item.order - 1 : 1;
            if (parentId != null) {
                order = item.order ? item.order + 1 : 1;
            }
            const data = {
                Name: "New Segment",
                Colour: colors[Math.floor(Math.random() * colors.length)],
                Order: order,
                FkParentWheelId: parentId
            };

            $.ajax({
                url: '/api/WheelApi/save',
                type: 'POST',
                contentType: 'application/json',
                data: JSON.stringify(data),
                success: function (response) {
                    console.log("Add Resp", response);
                    if (response.success) {
                        showToast('New Segment added successfully!');
                        editMode = true;
                        GetParentDropDown();
                    } else {
                        showToast('Failed to add new segment.', 'danger');
                    }
                },
                error: function () {
                    showToast('Error occurred during add.', 'danger');
                }
            });
        }

        function toggleEdit() {
            editMode = !editMode;
            if (!isSubBoxesActive || selectedSubSegment === null) {
                hoveredSubSegment = null;
                hoveredGrandSegment = null;
            }
            updateCanvasHeight();
            drawWheel();
        }

        window.addEventListener('resize', debounce(resizeCanvas, 100));
        resizeCanvas();
       // GetParentDropDown();
    </script>
}